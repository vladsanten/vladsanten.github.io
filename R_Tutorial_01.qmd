---
title: "Back to Basics R"
editor: visual
# https://pythonpanama.github.io/pythonpractico/
# http://progra.usm.cl/apunte/materia/expresiones.html
# https://fhernanb.github.io/Manual-de-R/
# https://host.kelley.iu.edu/nstoffma/
# https://mitsloan.mit.edu/ideas-made-to-matter/machine-learning-explained
# https://pythonpanama.github.io/pythonpractico/

---

### Primer acercamiento a R

<p>Este es un tutorial básico de R. Si ya sabes algo de <code>R</code> no creo que encuentres mucho acá. Las <em>expresiones</em>, <em>sentencias</em> y <em>procedimientos</em> mostrados se ejecutaron en el <em>IDE</em> de <code>RStudio</code></p>

<p> <b>Nota:</b> En programación, una **sentencia** y una **expresión** son conceptos diferentes:

1. **Expresión**: Es una combinación de valores, variables y operadores que da como resultado un valor único. Las expresiones en la mayoría de los lenguajes de programación pueden ser simples (como `3 + 5`) o más complejas (como `2 * (3 + 5)`). En R, un ejemplo de expresión podría ser:

```{r, eval=FALSE}
resultado <- sqrt(3) + 5
```

En esta expresión, `sqrt(3) + 5` es la parte que produce el valor, y luego ese valor puede ser asignado a la variable, e.g., `resultado`.

2. **Sentencia**: Es una unidad de código que realiza una acción específica. Una sentencia en un lenguaje de programación generalmente realiza una tarea, como asignar un valor a una variable, llamar a una función, o realizar una operación de control de flujo (como una instrucción `if` o un bucle `for`). En R, una sentencia simple podría ser:

```{r, eval=FALSE}
resultado <- sqrt(3) + 5
```

Esta línea de código es tanto una expresión como una sentencia. Es una sentencia porque realiza la acción de asignar el resultado de `sqrt(3) + 5` a la variable `resultado`, y es una expresión porque la expresión `sqrt(3) + 5` produce un valor que se asigna a `resultado`. 

Observe que, todas las expresiones son sentencias, pero no todas las sentencias son expresiones. Las expresiones producen <em>valores</em>, mientras que las sentencias <em>realizan acciones en el programa</em>.

<h2>
<center>Lo clásico</center>
</h2>

<ol>
<li><strong>Historia patria:</strong> Inicios y una anecdota...</li>
<li><strong>Sobre la instalación:</strong> Para seguir este tutorial debe tener instalado tanto <code>R</code> (<em>programa que hace el trabajo sucio, cálculos y demas</em>), como <code>RStudio</code> (<em> un entorno de trabajo que permite interactuar con el leguaje de manera mas eficiente e intuitiva</em>). Para esto sugiero los siguientes tutoriales que resultan facil de seguir.</li>

<li>

<strong>Sobre la instalación:</strong> Explorando <em>RStudio</em>, conociendo los paneles de trabajo: <code>Consola, Editor, Panel de entornos</code>, y <code>Panel de vista</code>. Estos dos últimos iran tomando sentido y la importancia que merecen a medida que se avance en el conocimiento de lo que es <code>R</code>.
<br><b>Nota:</b> En un inicio lo mas importante es saber los usos de la <code>Consola</code>, scripts (<code> Editor</code>) y la fución de ayuda (en la pestaña de <em>Help</em>) en el <code>Panel Vista</code></br>
<li> <b>La magia de <code>R</code>:</b> Programación de objetos </li>

<li> <b> Instalando paquetes:</b> Para usar un paquete en <code>R</code> debemos hacer dos cosas, instalar el paquete (solo se hace una vez, por el momento) <code>install.packages()</code> y cargarlo <code> library()</code>, esto ultimo cada vez que se use en una sesión </li>
</ol>
Acontinuación se muestra como hacerlo digitando código:
```{r,eval = FALSE}
# El nombre del paquete a instalar, siempre entre comillas
install.packages('nombre_paquete')
# Suponiendo que se ha instalado, lo cargamos y no deberia generar error
library(nombre_paquete)
```

<p><b>Consejo profesional </b>(No lo soy, pero igual): Por más pequeño que sea en lo que estes trabajando, siempre siempre crea un proyecto y luego crea internamente tus documentos para trabajar sobre estos.</p>


<h2>
<center>R Como Cálculadora (algo original :V)</center>
</h2>
Como en todo lenguaje de programación, es usual empezar a interactuar con este en forma de calculadora, y lo haremos con <code>R</code>. A continuación se listan las operaciones más basicas (su símbolo, descripción y ejemplo junto con su salida), las cuales bastaran para nuestro fin.

<!---Para ello consideraremos las operaciones algebraicas usuales y algunas operaciones básicas en los reales--->

<style>
    table {
        border-collapse: collapse;
        width: 100%;
    }
    
    th, td {
        border: 1px solid black;
        padding: 8px;
        text-align: left;
    }
</style>
<table>
  <tr>
    <th>Símbolo</th>
    <th>Descripción</th>
    <th>Ejemplo</th>
    <th>Salida</th>
  </tr>
  <tr>
    <td><code>+</code></td>
    <td>Operador binario para sumar</td>
    <td><code>5 + 17</code></td>
    <th><code> 22</code></th>
  </tr>
  <tr>
    <td><code>-</code></td>
    <td>Operador binario para restar</td>
    <td><code>10 - 3</code></td>
    <th><code>7</code></th>
  </tr>
  <tr>
    <td><code>*</code></td>
    <td>Operador binario para multiplicar</td>
    <td><code>4 * 6</code></td>
    <th><code> 24</code></th>
  </tr>
  <tr>
    <td><code>/</code></td>
    <td>Operador binario para dividir</td>
    <td><code>20 / 5</code></td>
    <th><code> 4</code></th>
  </tr>
  <tr>
    <td><code>^</code></td>
    <td>Operador binario para potencia</td>
    <td><code>2^3</code></td>
    <th><code> 8</code></th>
  </tr>
  <tr>
    <td><code>%/%</code></td>
    <td>Operador binario para obtener el cociente en una división (número entero)</td>
    <td><code>10%/%3 </code></td>
    <th><code> 3</code></th>
  </tr>
  <tr>
    <td><code>%%</code></td>
    <td>Operador binario para obtener el residuo en una división</td>
    <td><code>10 %% 3</code></td>
    <th><code> 1</code></th>
  </tr>
</table>


<p>Ahora vamos a <code>R</code>, acá se supone que las expresiones estan siendo ingresadas en consola, poe el momento. Importante para evaluar una <em>expresión</em> se ingrasa en la consola y damos <code>enter ()</code>. Así las cosas para la primera expresión a continuación tenemos: <code>'5 + 17' + (enter)</code></p>

```{r, eval=FALSE}
> # Suma  
> 5 + 17
[1] 22
> # Resta 
> 10 - 3
[1] 7
> # Multiplicación 
> 4 * 6
[1] 24
> # División usual 
> 20 / 5
[1] 4
> # Potenciación 
> 2^3
[1] 8
> # Cociente de la división 
> 10 %/% 3
[1] 3
> # Residuo de la división  
> 10 %% 3
[1] 1
```

<p><b>Nota:</b> <code>R</code> usa un punto ($\cdot$), como separador decimal. Es importante tener esto en cuenta para evitar confusiones y errores innecesarios. Veamoslo:</p>


```{r, eval=FALSE}
> 2,25 + 2.45
Error: inesperado ',' en "2,"
```


<h3>
Precedencia de operaciones y usos de parentesis
</h3>
<p>Tabla y notas sobre presedencia de operaciones...</p>
<h3>
Funciones matemáticas ususales
</h3>
<p>Revisaremos como se llaman y se operan algunas funciones matemáticas presentes en <code>R</code> por defecto.</p>

<h3>
Argumentos de funciones
</h3>
<p> Argumentos de funciones, seno, logaritmosss<p>


<h3>
Notación cientifica en <code>R</code> y funciones de redondeo: <code>round(), trunc(), floor(), ceiling(). </code>
</h3>
<h4>Sobre notación cientifica</h4>
Que es notación cientifica...
<p>Dependiendo el contexto de</p>
Tabla de funciones...
Sobre el nonbre se variables
Remover variables de memoria

<h2>
<center> Funciones y variables en <code>R</code>: Definición y usos. <code></code></center>
</h2>

<h3> Variables </h3>

<p>Las <em>variables</em> como su nombre lo dice son simplemente variables, en <code>R</code> estas corresponderan a nombres de <em>objetos</em> (<code>números, vectores, matrices, funciones, listas, tablas, arrays...</code>) que guardan algún <em>valor</em>, estas iran variando de acuerdo a las asignaciones que se le hagan sobre la marcha. Esto será muy util a la  hora de hacer algún <em>script</em> para solucionar una tarea o problema.</p>

<p> En otras palabras, una <em>variable</em> es el nombre que le damos un objeto que guarda un valor de un dato y con el cual haremos referencia a este para operar dentro del entorno</p>

<p>Veamos las diferentes formas de definir variables en <code>R</code>:</p>

```{r, eval=FALSE}
var <- valor
valor -> var
var = valor


```

<p><b>Nota:</b> el operador de asignación por defecto que utilizaremos sera <code> <- </code>, i.e., <code> Var <- valor </code> </p>

<h4> Definición de funciones: </h4>

```{r, eval=FALSE}
nombre_funcion <- function(var1,var2,...,varn){definición y estructura}
```
<h3> Sobre los nombres de funciones y variables: </h3>

Los nombres tanto de <em>variables</em> como de <em>funciones</em> deben empezar por una letra o un punto (no se admiten letras o caracteres), ademas los símbolos/carácteres permitidos para comformar estos serán:

<ul>
<li> Letras: mayúsculas, minúsculas, acentos (se recomienda no utilizar).</li>
<li> Digitos:<code>0,1,2,. . .,9</code> </li>
<li> Caracteres: <code>.</code> y <code>_</code></li>
</ul>


<h3> Removiendo/eliminado objetos en  memoria: funciones y variables: </h3>
<p>Para borrar un objeto particilar presente en memoria, usamos el <em>comando</em> <code>rm()</code></p>


<h3> Ejemplo de función: La raíz  <em>n-ésima</em> de un número real</h3>

```{r}
raiz_n_esima <- function(x,y){if(x >0){x^(1/y)}
							  else if(x==0){print("Es uno")}
							  else{print("Su numero es menor a cero")}}


```



Para una definición de la raíz $n-\text{ésima}$ de un número real positivo $\mathbb{R}^{+}$, como una función del conjunto de los números reales positivo $\mathbb{R}^{+}$, en los complejos $\mathbb{C}^{}$,  es decir $f:\mathbb{R}^{+} \rightarrow \mathbb{C}$

Así, para un número real $x \in \mathbb{R}^{+}$ y un exponente entero positivo $n \in \mathbb{N}^{+}$:

$$
f(x) = 
\begin{cases} 
\text{El único número complejo } z \text{ tal que } z^n = x & \text{si } x \geq 0 \\
\text{No está definido} & \text{si } x < 0 \\
\end{cases}
$$

2. **Si $x$ es negativo**: En el conjunto de los números complejos, la raíz n-ésima de $x$ puede ser definida como un conjunto de  $n$ números complejos distintos $z_k$ para $k = 0, 1, 2, ..., n-1$, donde 
$z_{k} = r_{k} \cdot e^{i\theta_{k}}$, con $r_{k} = \sqrt[n]{|x|}$ y $\theta_{k} = \frac{\arg(x) + 2\pi k}{n}$, para $k = 0, 1, 2,\ldots, n-1$, siendo $\arg(x)$ el argumento principal de $x$.

$$
f(x) = 
\begin{cases} 
\{ z_0, z_1, z_2, ..., z_{n-1} \} & \text{si } x < 0 \\
\end{cases}
$$

Esta definición se aplica a los números reales negativos.

La función raíz $n-ésima$ de un número real a los números complejos se define de la siguiente manera:

Sea $f: \mathbb{R} \rightarrow \mathbb{C}$ una función que asigna a cada número real su raíz n-ésima en el conjunto de los números complejos:

$$
f(x) = 
\begin{cases} 
\sqrt[n]{x} & \text{si } x \geq 0 \\
\sqrt[n]{|x|} \cdot e^{i\pi} & \text{si } x < 0 \\
\end{cases}
$$

Donde $e^{i\pi}$ es la unidad imaginaria $i$ multiplicada por $\pi$, que representa un ángulo de $\pi$ radianes en la forma polar. Esta expresión se obtiene al considerar que la raíz n-ésima de un número negativo en los números complejos se puede escribir como el módulo de ese número multiplicado por $e^{i\pi}$, lo que representa una rotación de $\pi$ radianes en el plano complejo.

Esta función mapea los números reales no negativos en los números complejos de manera directa, mientras que para los números reales negativos, devuelve un número complejo cuyo módulo es la raíz n-ésima del valor absoluto de $x$ y cuyo argumento (ángulo) es $\pi$.

<!----
https://personales.unican.es/rasillad/docencia/G14/TEMA_1/Estructuras_Datos.html
--->
<h2> <center>Estructura de datos</center> </h2>
<p>Las <em>estructuras de datos</em> son objetos que contienen datos almacenados y organizados de una manera particular. Una estructuras tienen diferentes características, como su dimensión y si son homogeneas o hereterogeneas respecto al tipo de datos que contienen almacenados.</p>

<p> La siguiente imagen contiene las estructuras de datos más comunes en <code>R</code>, junto con su representacion intuitiva de su configuración interna.</p>
![Estructuras de datos en R](Estructuras.png){width=80%}
<p>Parrrafo de texro 2</p>

La siguiente tabla muestra las principales estructuras de datos que maneja R.
<h3> Escalares:  </h3>
chat

<h3> Vectores:  </h3>
chat

<h3> Matrices:  </h3>
chat

<p>Parrrafo de texro 3</p>

<h3> Trabajano con un <em> dataframe </em></h3>
<p>Utilizaremos el conjunto de datos <code>ToothGrowth</code>, este dataframe viene almacenado por defecto en <code>R</code>. Siempre que se este trabajando con datos es importante conocer el contexto en el que los datos fueron registrados y sus fines, o al menos que tipo de datos tenemos.<p>
<p> <b>Descripción: </b> El dataframe contine la respuesta es la longitud de los <em>odontoblastos</em> (células responsables del crecimiento de los dientes) en 60 <em>cobayas/cuyes</em>. Cada animal recibió uno de los tres niveles de dosis de <em>vitamina C </em> <code>(0,5, 1 y 2 mg/día)</code> mediante uno de dos métodos de administración: jugo de naranja o ácido ascórbico (una forma de vitamina C codificada como VC). El tamaño del conjunto de datos es de 60 observaciones sobre 3 variables.</p>


[,1]	len	numérico	Longitud del diente
[,2]	supp	factor	Tipo de suplemento (VC o DO). 
[,3]	dose	numérico	Dosis en miligramos/día

<p> Para conocer el contenido y estructura de una variable almacenada en <code>R</code>, existen algunas funcion definidas por defencto. Las mas usuales son:  <code> str(), class(), head()</code>. </p>


```{r}
```


```{r,eval=TRUE,echo=TRUE}
head(ToothGrowth)
require(graphics)
coplot(len ~ dose | supp, data = ToothGrowth, panel = panel.smooth,
       xlab = "Datos de crecimiento de diente : longitud vs dosis, dado el tipo de suplemento VC/OJ")
```


<h3> Un modelo clásico de estadística: regresión lineal</h3>
-buscar ejemplo con chat...

<h2> <center> Cargando datos: diferentes fuente y formatos </center></h2>
chat

```{r}
```

Claro, vamos a profundizar en la función `walk` del paquete `purrr` en R.

### Introducción a `purrr::walk`

El paquete `purrr` es parte del conjunto de paquetes `tidyverse` y se utiliza para realizar operaciones funcionales de manera eficiente y elegante. Proporciona funciones para trabajar con listas y vectores de una manera más intuitiva que las funciones base de R.

### Función `walk`

La función `walk` en `purrr` es una función de orden superior utilizada para aplicar una función a cada elemento de una lista o vector de manera que se ejecuten efectos secundarios. Es similar a `lapply` o `sapply` en el sentido de que aplica una función a cada elemento de una lista, pero se diferencia en que `walk` no devuelve nada (o más precisamente, devuelve la lista de entrada invisiblemente). Es útil cuando necesitas aplicar una función que realiza una acción, como imprimir o escribir en un archivo, y no necesitas los resultados.

### Sintaxis

La sintaxis básica de `walk` es:
```R
walk(.x, .f, ...)
```
Donde:

  + `.x` es la lista o vector sobre el cual se va a iterar.
  
  + `.f` es la función que se aplicará a cada elemento de `.x`.
  
  + `...` son argumentos adicionales que se pasan a `.f`.

### Ejemplo con `walk`

Veamos un ejemplo simple para entender cómo funciona `walk`:

```R
library(purrr)

# Lista de objetos sobre los cuales se va a iterar (nombres, en nuestro ejemplo)
nombres <- c("Lizeth", "Daniel", "Carlos")

# Función básica para imprimir un saludo
saludar <- function(nombres) {
  cat("Hola",nombres,"!\n")
}

# Usando 'walk' para aplicar la función 'saludar' a cada nombre en la lista
walk(nombres,saludar)
```

Así, `walk` aplica la función `saludar` a cada elemento de la lista `nombres` y ejecuta el efecto secundario de imprimir un saludo para cada nombre.

### Ejemplo de uso de `walk` (verificación de paquetes)

Frecuentemente olvidamos si tenemos o no algunos paquetes instalados, y seriá de utilidad tener una manera rapidad de comprobar y hacer la instalación. Luego utilizaremos `walk` para iterar sobre una lista de paquetes y verificar si cada uno está instalado, o no lo está. Esta nos permitirá iterar sobre la lista de paquetes de interes y aplicar una función que verifica e instala los paquetes listados sin preocuparnos por los valores de retorno, enfocándonos solo en los efectos secundarios (la instalación de paquetes). Para el ejemplo listaremos paquetes de uso común en análisis de datos, modelado predictivo y procesamiento de texto.
```R
packages <- c( 
              "broom", "forcats", "hcandersenr", "janitor", "LDAvis", "lubridate", 
              "magrittr", "naivebayes", "polite", "ranger", "rtweet", "rvest", "sotu", 
              "spacyr", "stm", "stmBrowser", "stmCorrViz", "textdata", "textrecipes", 
              "tidymodels", "tidytext", "topicmodels", "tune", "wordcloud", "workflows", 
              "yardstick"
              )

purrr::walk(
            packages, 
            ~{if (!.x %in% installed.packages()[, 1]) install.packages(.x)}
            )
```

### A tener en cuenta en lo anterior:

1. **Lista de paquetes**: Se define una lista `packages` con los nombres de los paquetes que deseamos tener disponibles.
2. **Función anónima en `walk`**:
   - `purrr::walk(packages, ~{ ... })`: `walk` itera sobre cada elemento en `packages`.
   - `~{ ... }`: La tilde (`~`) se usa para definir una función anónima (lambda) en `purrr`. Es una forma corta de definir una función en línea.
   - `.x` es el argumento implícito que representa el elemento actual de `packages` durante cada iteración.
   - `if (!.x %in% installed.packages()[, 1]) install.packages(.x)`: Para cada paquete `.x`, verifica si está instalado (`.x %in% installed.packages()[, 1]`). Si no lo está, lo instala (`install.packages(.x)`).


<!---
--------------------------------------------------------------

![](Estructuras.png){fig-alt="Estructuras de datos en R."}
![Estructuras de datos en R](Estructuras.png){width=80%}
{width=600}
<ul>
<li></li>
<li></li>
</ul>
<img src="Estructuras_R.pdf" />

<img
  src="Estructuras_R.pdf"
  alt="La cabeza y el torso de un esqueleto de dinosaurio;
           tiene una cabeza grande con dientes largos y afilados"
  width="200"
  height="161" />

<h3> </h3>
<center></center>
<code></code>
<em></em>
--------------------------------------------------------------------------
--->

